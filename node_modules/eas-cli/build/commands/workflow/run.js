"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@oclif/core");
const core_2 = require("@urql/core");
const chalk_1 = tslib_1.__importDefault(require("chalk"));
const fs = tslib_1.__importStar(require("node:fs"));
const path = tslib_1.__importStar(require("node:path"));
const slash_1 = tslib_1.__importDefault(require("slash"));
const url_1 = require("../../build/utils/url");
const EasCommand_1 = tslib_1.__importDefault(require("../../commandUtils/EasCommand"));
const flags_1 = require("../../commandUtils/flags");
const generated_1 = require("../../graphql/generated");
const WorkflowRevisionMutation_1 = require("../../graphql/mutations/WorkflowRevisionMutation");
const WorkflowRunMutation_1 = require("../../graphql/mutations/WorkflowRunMutation");
const WorkflowRunQuery_1 = require("../../graphql/queries/WorkflowRunQuery");
const log_1 = tslib_1.__importStar(require("../../log"));
const ora_1 = require("../../ora");
const projectUtils_1 = require("../../project/projectUtils");
const uploadAccountScopedFileAsync_1 = require("../../project/uploadAccountScopedFileAsync");
const uploadAccountScopedProjectSourceAsync_1 = require("../../project/uploadAccountScopedProjectSourceAsync");
const json_1 = require("../../utils/json");
const promise_1 = require("../../utils/promise");
const workflowFile_1 = require("../../utils/workflowFile");
const EXIT_CODES = {
    WORKFLOW_FAILED: 11,
    WORKFLOW_CANCELED: 12,
    WAIT_ABORTED: 13,
};
class WorkflowRun extends EasCommand_1.default {
    static description = 'run an EAS workflow';
    static args = [{ name: 'file', description: 'Path to the workflow file to run' }];
    static flags = {
        ...flags_1.EASNonInteractiveFlag,
        wait: core_1.Flags.boolean({
            default: false,
            allowNo: true,
            description: 'Exit codes: 0 = success, 11 = failure, 12 = canceled, 13 = wait aborted.',
            summary: 'Wait for workflow run to complete',
        }),
        ...flags_1.EasJsonOnlyFlag,
    };
    static contextDefinition = {
        ...this.ContextOptions.DynamicProjectConfig,
        ...this.ContextOptions.ProjectDir,
        ...this.ContextOptions.Vcs,
        ...this.ContextOptions.LoggedIn,
    };
    async runAsync() {
        const { flags, args } = await this.parse(WorkflowRun);
        if (flags.json) {
            (0, json_1.enableJsonOutput)();
        }
        const { getDynamicPrivateProjectConfigAsync, loggedIn: { graphqlClient }, vcsClient, projectDir, } = await this.getContextAsync(WorkflowRun, {
            nonInteractive: flags['non-interactive'],
            withServerSideEnvironment: null,
        });
        let yamlConfig;
        try {
            const workflowFileContents = await workflowFile_1.WorkflowFile.readWorkflowFileContentsAsync({
                projectDir,
                filePath: args.file,
            });
            log_1.default.log(`Using workflow file from ${workflowFileContents.filePath}`);
            yamlConfig = workflowFileContents.yamlConfig;
        }
        catch (err) {
            log_1.default.error('Failed to read workflow file.');
            throw err;
        }
        const { projectId, exp: { slug: projectName }, } = await getDynamicPrivateProjectConfigAsync();
        const account = await (0, projectUtils_1.getOwnerAccountForProjectIdAsync)(graphqlClient, projectId);
        try {
            await WorkflowRevisionMutation_1.WorkflowRevisionMutation.validateWorkflowYamlConfigAsync(graphqlClient, {
                appId: projectId,
                yamlConfig,
            });
        }
        catch (error) {
            if (error instanceof core_2.CombinedError) {
                workflowFile_1.WorkflowFile.maybePrintWorkflowFileValidationErrors({
                    error,
                    accountName: account.name,
                    projectName,
                });
                throw error;
            }
        }
        let projectArchiveBucketKey;
        let easJsonBucketKey = null;
        let packageJsonBucketKey = null;
        const easJsonPath = path.join(projectDir, 'eas.json');
        const packageJsonPath = path.join(projectDir, 'package.json');
        const projectRootDirectory = (0, slash_1.default)(path.relative(await vcsClient.getRootPathAsync(), projectDir) || '.');
        try {
            ({ projectArchiveBucketKey } = await (0, uploadAccountScopedProjectSourceAsync_1.uploadAccountScopedProjectSourceAsync)({
                graphqlClient,
                vcsClient,
                accountId: account.id,
            }));
            if (await fileExistsAsync(easJsonPath)) {
                ({ fileBucketKey: easJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                    graphqlClient,
                    accountId: account.id,
                    filePath: easJsonPath,
                    maxSizeBytes: 1024 * 1024,
                }));
            }
            else {
                log_1.default.warn(`⚠ No ${chalk_1.default.bold('eas.json')} found in the project directory. Running ${chalk_1.default.bold('type: build')} jobs will not work. Run ${chalk_1.default.bold('eas build:configure')} to configure your project for builds.`);
            }
            if (await fileExistsAsync(packageJsonPath)) {
                ({ fileBucketKey: packageJsonBucketKey } = await (0, uploadAccountScopedFileAsync_1.uploadAccountScopedFileAsync)({
                    graphqlClient,
                    accountId: account.id,
                    filePath: packageJsonPath,
                    maxSizeBytes: 1024 * 1024,
                }));
            }
            else {
                log_1.default.warn(`⚠ No ${chalk_1.default.bold('package.json')} found in the project directory. It is used to automatically infer best job configuration for your project. You may want to define ${chalk_1.default.bold('image')} property in your workflow to specify the image to use.`);
            }
        }
        catch (err) {
            log_1.default.error('Failed to upload project sources.');
            throw err;
        }
        let workflowRunId;
        try {
            ({ id: workflowRunId } = await WorkflowRunMutation_1.WorkflowRunMutation.createWorkflowRunAsync(graphqlClient, {
                appId: projectId,
                workflowRevisionInput: {
                    fileName: path.basename(args.file),
                    yamlConfig,
                },
                workflowRunInput: {
                    projectSource: {
                        type: generated_1.WorkflowProjectSourceType.Gcs,
                        projectArchiveBucketKey,
                        easJsonBucketKey,
                        packageJsonBucketKey,
                        projectRootDirectory,
                    },
                },
            }));
            log_1.default.newLine();
            log_1.default.log(`See logs: ${(0, log_1.link)((0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId))}`);
        }
        catch (err) {
            log_1.default.error('Failed to start the workflow with the API.');
            throw err;
        }
        if (!flags.wait) {
            if (flags.json) {
                (0, json_1.printJsonOnlyOutput)({
                    id: workflowRunId,
                    url: (0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId),
                });
            }
            process.exit(0);
        }
        log_1.default.newLine();
        const { status } = await waitForWorkflowRunToEndAsync(graphqlClient, {
            workflowRunId,
        });
        if (flags.json) {
            const workflowRun = await WorkflowRunQuery_1.WorkflowRunQuery.withJobsByIdAsync(graphqlClient, workflowRunId, {
                useCache: false,
            });
            (0, json_1.printJsonOnlyOutput)({
                ...workflowRun,
                url: (0, url_1.getWorkflowRunUrl)(account.name, projectName, workflowRunId),
            });
        }
        if (status === generated_1.WorkflowRunStatus.Failure) {
            process.exit(EXIT_CODES.WORKFLOW_FAILED);
        }
        else if (status === generated_1.WorkflowRunStatus.Canceled) {
            process.exit(EXIT_CODES.WORKFLOW_CANCELED);
        }
    }
}
exports.default = WorkflowRun;
async function waitForWorkflowRunToEndAsync(graphqlClient, { workflowRunId }) {
    log_1.default.log('Waiting for workflow run to complete. You can press Ctrl+C to exit.');
    const spinner = (0, ora_1.ora)('Currently waiting for workflow run to start.').start();
    let failedFetchesCount = 0;
    while (true) {
        try {
            const workflowRun = await WorkflowRunQuery_1.WorkflowRunQuery.byIdAsync(graphqlClient, workflowRunId, {
                useCache: false,
            });
            failedFetchesCount = 0;
            switch (workflowRun.status) {
                case generated_1.WorkflowRunStatus.InProgress:
                    spinner.start('Workflow run is in progress.');
                    break;
                case generated_1.WorkflowRunStatus.ActionRequired:
                    spinner.warn('Workflow run is waiting for action.');
                    break;
                case generated_1.WorkflowRunStatus.Canceled:
                    spinner.warn('Workflow run has been canceled.');
                    return workflowRun;
                case generated_1.WorkflowRunStatus.Failure:
                    spinner.fail('Workflow run has failed.');
                    return workflowRun;
                case generated_1.WorkflowRunStatus.Success:
                    spinner.succeed('Workflow run completed successfully.');
                    return workflowRun;
            }
        }
        catch {
            spinner.text = '⚠ Failed to fetch the workflow run status. Check your network connection.';
            failedFetchesCount += 1;
            if (failedFetchesCount > 6) {
                spinner.fail('Failed to fetch the workflow run status 6 times in a row. Aborting wait.');
                process.exit(EXIT_CODES.WAIT_ABORTED);
            }
        }
        await (0, promise_1.sleepAsync)(10 /* seconds */ * 1000 /* milliseconds */);
    }
}
async function fileExistsAsync(filePath) {
    return await fs.promises
        .access(filePath, fs.constants.F_OK)
        .then(() => true)
        .catch(() => false);
}
