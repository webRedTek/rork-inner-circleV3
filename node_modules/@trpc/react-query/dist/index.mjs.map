{"version":3,"file":"index.mjs","names":["trpc: CreateReactQueryHooks<TRouter, TSSRContext>","opts?: CreateTRPCReactOptions<TRouter>","opts: CreateQueryUtilsOptions<TRouter>"],"sources":["../src/createTRPCReact.tsx","../src/createTRPCQueryUtils.tsx"],"sourcesContent":["import type {\n  DefinedInitialDataInfiniteOptions,\n  DefinedUseInfiniteQueryResult,\n  InfiniteData,\n  SkipToken,\n  UndefinedInitialDataInfiniteOptions,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n  UseSuspenseQueryResult,\n} from '@tanstack/react-query';\nimport type { createTRPCClient, TRPCClientErrorLike } from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferAsyncIterableYield,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  ProtectedIntersection,\n  RouterRecord,\n  Simplify,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from './internals/useQueries';\nimport type {\n  CreateReactUtils,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n} from './shared';\nimport { createReactDecoration, createReactQueryUtils } from './shared';\nimport type { CreateReactQueryHooks } from './shared/hooks/createHooksInternal';\nimport { createRootHooks } from './shared/hooks/createHooksInternal';\nimport type {\n  DefinedUseTRPCQueryOptions,\n  DefinedUseTRPCQueryResult,\n  TRPCHookResult,\n  TRPCProvider,\n  TRPCSubscriptionResult,\n  TRPCUseQueryBaseOptions,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseQueryOptions,\n} from './shared/hooks/types';\nimport type { CreateTRPCReactOptions } from './shared/types';\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n/**\n * @internal\n */\nexport interface ProcedureUseQuery<TDef extends ResolverDef> {\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts: DefinedUseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<{\n        errorShape: TDef['errorShape'];\n        transformer: TDef['transformer'];\n      }>,\n      TDef['output']\n    >,\n  ): DefinedUseTRPCQueryResult<\n    TData,\n    TRPCClientErrorLike<{\n      errorShape: TDef['errorShape'];\n      transformer: TDef['transformer'];\n    }>\n  >;\n\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts?: UseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>,\n      TDef['output']\n    >,\n  ): UseTRPCQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n/**\n * @internal\n */\nexport type ProcedureUsePrefetchQuery<TDef extends ResolverDef> = (\n  input: TDef['input'] | SkipToken,\n  opts?: TRPCFetchQueryOptions<TDef['output'], TRPCClientErrorLike<TDef>>,\n) => void;\n\n/**\n * @remark `void` is here due to https://github.com/trpc/trpc/pull/4374\n */\ntype CursorInput = {\n  cursor?: any;\n} | void;\n\ntype ReservedInfiniteQueryKeys = 'cursor' | 'direction';\ntype InfiniteInput<TInput> =\n  | Omit<TInput, ReservedInfiniteQueryKeys>\n  | SkipToken;\n\ntype inferCursorType<TInput> = TInput extends { cursor?: any }\n  ? TInput['cursor']\n  : unknown;\n\ntype makeInfiniteQueryOptions<TCursor, TOptions> = Omit<\n  TOptions,\n  'queryKey' | 'initialPageParam' | 'queryFn' | 'queryHash' | 'queryHashFn'\n> &\n  TRPCUseQueryBaseOptions & {\n    initialCursor?: TCursor;\n  };\n\ntype trpcInfiniteData<TDef extends ResolverDef> = Simplify<\n  InfiniteData<TDef['output'], inferCursorType<TDef['input']>>\n>;\n// references from react-query\n// 1st\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: DefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): DefinedUseInfiniteQueryResult<TData, TError>;\n// 2nd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UndefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n// 3rd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n\nexport interface useTRPCInfiniteQuery<TDef extends ResolverDef> {\n  // 1st\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      DefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult &\n    DefinedUseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 2nd\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UndefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 3rd:\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UseInfiniteQueryOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n// references from react-query\n// declare function useSuspenseInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseSuspenseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseSuspenseInfiniteQueryResult<TData, TError>;\n\nexport type useTRPCSuspenseInfiniteQuery<TDef extends ResolverDef> = (\n  input: InfiniteInput<TDef['input']>,\n  opts: makeInfiniteQueryOptions<\n    inferCursorType<TDef['input']>,\n    UseSuspenseInfiniteQueryOptions<\n      //     TQueryFnData,\n      TDef['output'],\n      //     TError,\n      TRPCClientErrorLike<TDef>,\n      //     TData,\n      trpcInfiniteData<TDef>,\n      //     TQueryKey,\n      any,\n      //     TPageParam\n      inferCursorType<TDef['input']>\n    >\n  >,\n) => [\n  trpcInfiniteData<TDef>,\n  TRPCHookResult &\n    UseSuspenseInfiniteQueryResult<\n      trpcInfiniteData<TDef>,\n      TRPCClientErrorLike<TDef>\n    >,\n];\n\n/**\n * @internal\n */\nexport type MaybeDecoratedInfiniteQuery<TDef extends ResolverDef> =\n  TDef['input'] extends CursorInput\n    ? {\n        /**\n         * @see https://trpc.io/docs/v11/client/react/useInfiniteQuery\n         */\n        useInfiniteQuery: useTRPCInfiniteQuery<TDef>;\n        /**\n         * @see https://trpc.io/docs/client/react/suspense#usesuspenseinfinitequery\n         */\n        useSuspenseInfiniteQuery: useTRPCSuspenseInfiniteQuery<TDef>;\n\n        usePrefetchInfiniteQuery: (\n          input: Omit<TDef['input'], ReservedInfiniteQueryKeys> | SkipToken,\n          opts: TRPCFetchInfiniteQueryOptions<\n            TDef['input'],\n            TDef['output'],\n            TRPCClientErrorLike<TDef>\n          >,\n        ) => void;\n      }\n    : object;\n\n/**\n * @internal\n */\nexport type DecoratedQueryMethods<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useQuery\n   */\n  useQuery: ProcedureUseQuery<TDef>;\n  usePrefetchQuery: ProcedureUsePrefetchQuery<TDef>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/suspense#usesuspensequery\n   */\n  useSuspenseQuery: <\n    TQueryFnData extends TDef['output'] = TDef['output'],\n    TData = TQueryFnData,\n  >(\n    input: TDef['input'],\n    opts?: UseTRPCSuspenseQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>\n    >,\n  ) => [\n    TData,\n    UseSuspenseQueryResult<TData, TRPCClientErrorLike<TDef>> & TRPCHookResult,\n  ];\n};\n\n/**\n * @internal\n */\nexport type DecoratedQuery<TDef extends ResolverDef> =\n  MaybeDecoratedInfiniteQuery<TDef> & DecoratedQueryMethods<TDef>;\n\nexport type DecoratedMutation<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useMutation\n   */\n  useMutation: <TContext = unknown>(\n    opts?: UseTRPCMutationOptions<\n      TDef['input'],\n      TRPCClientErrorLike<TDef>,\n      TDef['output'],\n      TContext\n    >,\n  ) => UseTRPCMutationResult<\n    TDef['output'],\n    TRPCClientErrorLike<TDef>,\n    TDef['input'],\n    TContext\n  >;\n};\n\ninterface ProcedureUseSubscription<TDef extends ResolverDef> {\n  // Without skip token\n  (\n    input: TDef['input'],\n    opts?: UseTRPCSubscriptionOptions<\n      inferAsyncIterableYield<TDef['output']>,\n      TRPCClientErrorLike<TDef>\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n\n  // With skip token\n  (\n    input: TDef['input'] | SkipToken,\n    opts?: Omit<\n      UseTRPCSubscriptionOptions<\n        inferAsyncIterableYield<TDef['output']>,\n        TRPCClientErrorLike<TDef>\n      >,\n      'enabled'\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n}\n/**\n * @internal\n */\nexport type DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? DecoratedQuery<TDef>\n  : TType extends 'mutation'\n    ? DecoratedMutation<TDef>\n    : TType extends 'subscription'\n      ? {\n          /**\n           * @see https://trpc.io/docs/v11/subscriptions\n           */\n          useSubscription: ProcedureUseSubscription<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<TRoot, $Value>;\n            transformer: TRoot['transformer'];\n            errorShape: TRoot['errorShape'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport type CreateTRPCReactBase<TRouter extends AnyRouter, TSSRContext> = {\n  /**\n   * @deprecated renamed to `useUtils` and will be removed in a future tRPC version\n   *\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useContext(): CreateReactUtils<TRouter, TSSRContext>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useUtils(): CreateReactUtils<TRouter, TSSRContext>;\n  Provider: TRPCProvider<TRouter, TSSRContext>;\n  createClient: typeof createTRPCClient<TRouter>;\n  useQueries: TRPCUseQueries<TRouter>;\n  useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>;\n};\n\nexport type CreateTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  CreateTRPCReactBase<TRouter, TSSRContext>,\n  DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\n/**\n * @internal\n */\nexport function createHooksInternal<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(trpc: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  type CreateHooksInternal = CreateTRPCReact<TRouter, TSSRContext>;\n\n  const proxy = createReactDecoration<TRouter, TSSRContext>(\n    trpc,\n  ) as DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n  return createFlatProxy<CreateHooksInternal>((key) => {\n    if (key === 'useContext' || key === 'useUtils') {\n      return () => {\n        const context = trpc.useUtils();\n        // create a stable reference of the utils context\n        return React.useMemo(() => {\n          return (createReactQueryUtils as any)(context);\n        }, [context]);\n      };\n    }\n\n    if (trpc.hasOwnProperty(key)) {\n      return (trpc as any)[key];\n    }\n\n    return proxy[key];\n  });\n}\n\nexport function createTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(\n  opts?: CreateTRPCReactOptions<TRouter>,\n): CreateTRPCReact<TRouter, TSSRContext> {\n  const hooks = createRootHooks<TRouter, TSSRContext>(opts);\n  const proxy = createHooksInternal<TRouter, TSSRContext>(hooks);\n\n  return proxy as any;\n}\n","import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createQueryUtilsProxy } from './shared';\nimport type { CreateQueryUtilsOptions } from './utils/createUtilityFunctions';\nimport { createUtilityFunctions } from './utils/createUtilityFunctions';\n\nexport function createTRPCQueryUtils<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n) {\n  const utils = createUtilityFunctions(opts);\n  return createQueryUtilsProxy<TRouter>(utils);\n}\n"],"mappings":";;;;;;;;;;;AA4dA,SAAgB,oBAGdA,MAAmD;CAGnD,MAAM,QAAQ,sBACZ,KACD;AAID,QAAO,gBAAqC,CAAC,QAAQ;AACnD,MAAI,QAAQ,gBAAgB,QAAQ,WAClC,QAAO,MAAM;GACX,MAAM,UAAU,KAAK,UAAU;AAE/B,UAAO,MAAM,QAAQ,MAAM;AACzB,WAAO,AAAC,sBAA8B,QAAQ;GAC/C,GAAE,CAAC,OAAQ,EAAC;EACd;AAGH,MAAI,KAAK,eAAe,IAAI,CAC1B,QAAQ,KAAa;AAGvB,SAAO,MAAM;CACd,EAAC;AACH;AAED,SAAgB,gBAIdC,MACuC;CACvC,MAAM,QAAQ,gBAAsC,KAAK;CACzD,MAAM,QAAQ,oBAA0C,MAAM;AAE9D,QAAO;AACR;;;;AChgBD,SAAgB,qBACdC,MACA;CACA,MAAM,QAAQ,uBAAuB,KAAK;AAC1C,QAAO,sBAA+B,MAAM;AAC7C"}