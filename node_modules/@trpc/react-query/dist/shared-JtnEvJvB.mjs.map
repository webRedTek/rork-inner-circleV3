{"version":3,"file":"shared-JtnEvJvB.mjs","names":["hooks: CreateReactQueryHooks<TRouter, TSSRContext>","contextProps: (keyof TRPCContextPropsBase<any, any>)[]","React","utilName: keyof AnyDecoratedProcedure","context: TRPCQueryUtils<TRouter>","contextMap: Record<keyof AnyDecoratedProcedure, () => unknown>","context: TRPCContextState<AnyRouter, TSSRContext>","client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>","untypedClient: TRPCUntypedClient<TRouter>","options: QueryOptions","queryKey: TRPCQueryKey","opts: TOptions","infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  }","_asyncIterator","r","AsyncFromSyncIterator","value: {\n  path: readonly string[];\n}","asyncIterable: AsyncIterable<unknown>","queryClient: QueryClient","queryKey: TRPCQueryKey","aggregate: unknown[]","opts: CreateQueryUtilsOptions<TRouter>","opts","queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>","queryFnContext: QueryFunctionContext<TRPCQueryKey>","input: unknown","result: T","onTrackResult: (key: keyof T) => void","config?: CreateTRPCReactOptions<TRouter>","mutationSuccessOverride: UseMutationOverride['onSuccess']","TRPCProvider: TRPCProvider<TRouter, TSSRContext>","client: TRPCUntypedClient<TRouter>","queryKey: TRPCQueryKey","opts: TOptions","useQuery","path: readonly string[]","input: unknown","opts?: UseTRPCQueryOptions<unknown, unknown, TError>","usePrefetchQuery","path: string[]","opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>","useSuspenseQuery","opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>","useMutation","opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>","initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'>","initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  >","opts: UseTRPCSubscriptionOptions<unknown, TError>","key: keyof $Result","callback: (prevState: $Result) => $Result","useInfiniteQuery","opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>","usePrefetchInfiniteQuery","opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>","useSuspenseInfiniteQuery","opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>","useQueries: TRPCUseQueries<TRouter>","useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>","config: CreateTRPCReactQueryClientConfig"],"sources":["../src/shared/proxy/decorationProxy.ts","../src/internals/context.tsx","../src/shared/proxy/utilsProxy.ts","../src/shared/proxy/useQueriesProxy.ts","../src/internals/getClientArgs.ts","../../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js","../src/internals/trpcResult.ts","../src/utils/createUtilityFunctions.ts","../src/shared/hooks/createHooksInternal.tsx","../src/shared/queryClient.ts"],"sourcesContent":["import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateReactQueryHooks } from '../hooks/createHooksInternal';\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */\nexport function createReactDecoration<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(hooks: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  return createRecursiveProxy(({ path, args }) => {\n    const pathCopy = [...path];\n\n    // The last arg is for instance `.useMutation` or `.useQuery()`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastArg = pathCopy.pop()!;\n\n    if (lastArg === 'useMutation') {\n      return (hooks as any)[lastArg](pathCopy, ...args);\n    }\n\n    if (lastArg === '_def') {\n      return {\n        path: pathCopy,\n      };\n    }\n\n    const [input, ...rest] = args;\n    const opts = rest[0] ?? {};\n\n    return (hooks as any)[lastArg](pathCopy, input, opts);\n  });\n}\n","import type {\n  CancelOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationOptions,\n  QueryClient,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/react-query';\nimport type {\n  TRPCClient,\n  TRPCClientError,\n  TRPCRequestOptions,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n  DistributiveOmit,\n} from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  ExtractCursorType,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n} from '../shared';\nimport type { TRPCMutationKey, TRPCQueryKey } from './getQueryKey';\n\ninterface TRPCUseUtilsOptions {\n  /**\n   * tRPC-related options\n   */\n  trpc?: TRPCRequestOptions;\n}\nexport interface TRPCFetchQueryOptions<TOutput, TError>\n  extends DistributiveOmit<FetchQueryOptions<TOutput, TError>, 'queryKey'>,\n    TRPCUseUtilsOptions {\n  //\n}\n\nexport type TRPCFetchInfiniteQueryOptions<TInput, TOutput, TError> =\n  DistributiveOmit<\n    FetchInfiniteQueryOptions<\n      TOutput,\n      TError,\n      TOutput,\n      TRPCQueryKey,\n      ExtractCursorType<TInput>\n    >,\n    'queryKey' | 'initialPageParam'\n  > &\n    TRPCUseUtilsOptions & {\n      initialCursor?: ExtractCursorType<TInput>;\n    };\n\n/** @internal */\nexport type SSRState = 'mounted' | 'mounting' | 'prepass' | false;\n\nexport interface TRPCContextPropsBase<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCUntypedClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * @deprecated pass abortOnUnmount to `createTRPCReact` instead\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n\n/**\n * @internal\n */\nexport type DecoratedTRPCContextProps<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = TRPCContextPropsBase<TRouter, TSSRContext> & {\n  client: TRPCClient<TRouter>;\n};\n\nexport interface TRPCContextProps<TRouter extends AnyRouter, TSSRContext>\n  extends TRPCContextPropsBase<TRouter, TSSRContext> {\n  /**\n   * The react-query `QueryClient`\n   */\n  queryClient: QueryClient;\n}\n\nexport const contextProps: (keyof TRPCContextPropsBase<any, any>)[] = [\n  'client',\n  'ssrContext',\n  'ssrState',\n  'abortOnUnmount',\n];\n\n/**\n * @internal\n */\nexport interface TRPCContextState<\n  TRouter extends AnyRouter,\n  TSSRContext = undefined,\n> extends Required<TRPCContextProps<TRouter, TSSRContext>>,\n    TRPCQueryUtils<TRouter> {}\n\n/**\n * @internal\n */\nexport interface TRPCQueryUtils<TRouter extends AnyRouter> {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: UndefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<InfiniteData<unknown, unknown>>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/prefetching\n   */\n  prefetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureQueryData: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidateQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: InvalidateQueryFilters<TRPCQueryKey>,\n    options?: InvalidateOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  resetQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: QueryFilters<TRPCQueryKey>,\n    options?: ResetOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetchQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: RefetchQueryFilters<TRPCQueryKey>,\n    options?: RefetchOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation\n   */\n  cancelQuery: (\n    queryKey: TRPCQueryKey,\n    options?: CancelOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetqueriesdata\n   */\n  setQueriesData: (\n    queryKey: TRPCQueryKey,\n    filters: QueryFilters,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => [QueryKey, unknown][];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getQueryData: (queryKey: TRPCQueryKey) => unknown;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<\n      InfiniteData<unknown> | undefined,\n      InfiniteData<unknown> | undefined\n    >,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n  ) => InfiniteData<unknown> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient/#queryclientsetmutationdefaults\n   */\n  setMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n    options:\n      | MutationOptions\n      | ((args: {\n          canonicalMutationFn: (input: unknown) => Promise<unknown>;\n        }) => MutationOptions),\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientgetmutationdefaults\n   */\n  getMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n  ) => MutationOptions | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientismutating\n   */\n  isMutating: (filters: { mutationKey: TRPCMutationKey }) => number;\n}\nexport const TRPCContext = React.createContext?.(null as any);\n","import type {\n  CancelOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  Query,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  SkipToken,\n  Updater,\n} from '@tanstack/react-query';\nimport type { TRPCClientError } from '@trpc/client';\nimport { createTRPCClientProxy } from '@trpc/client';\nimport type {\n  AnyMutationProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  DeepPartial,\n  inferProcedureInput,\n  inferProcedureOutput,\n  inferTransformedProcedureOutput,\n  ProtectedIntersection,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  DecoratedTRPCContextProps,\n  TRPCContextState,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n  TRPCQueryUtils,\n} from '../../internals/context';\nimport { contextProps } from '../../internals/context';\nimport type { QueryKeyKnown, QueryType } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport type { InferMutationOptions } from '../../utils/inferReactQueryProcedure';\nimport type { ExtractCursorType } from '../hooks/types';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsIn,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsOut,\n  UnusedSkipTokenTRPCQueryOptionsIn,\n  UnusedSkipTokenTRPCQueryOptionsOut,\n} from '../types';\n\nexport type DecorateQueryProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UnusedSkipTokenTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCQueryOptionsOut<\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure>,\n    opts: UnusedSkipTokenTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<\n    InfiniteData<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n    >\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchquery\n   */\n  prefetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureData(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientinvalidatequeries\n   */\n  invalidate(\n    input?: DeepPartial<inferProcedureInput<TProcedure>>,\n    filters?: Omit<InvalidateQueryFilters, 'predicate'> & {\n      predicate?: (\n        query: Query<\n          inferProcedureOutput<TProcedure>,\n          TRPCClientError<TRoot>,\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          QueryKeyKnown<\n            inferProcedureInput<TProcedure>,\n            inferProcedureInput<TProcedure> extends { cursor?: any } | void\n              ? 'infinite'\n              : 'query'\n          >\n        >,\n      ) => boolean;\n    },\n    options?: InvalidateOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetch(\n    input?: inferProcedureInput<TProcedure>,\n    filters?: RefetchQueryFilters,\n    options?: RefetchOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientcancelqueries\n   */\n  cancel(\n    input?: inferProcedureInput<TProcedure>,\n    options?: CancelOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  reset(\n    input?: inferProcedureInput<TProcedure>,\n    options?: ResetOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueriesData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    filters: QueryFilters,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): [QueryKey, inferTransformedProcedureOutput<TRoot, TProcedure>];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteData(\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined,\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getData(\n    input?: inferProcedureInput<TProcedure>,\n  ): inferTransformedProcedureOutput<TRoot, TProcedure> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteData(\n    input?: inferProcedureInput<TProcedure>,\n  ):\n    | InfiniteData<\n        inferTransformedProcedureOutput<TRoot, TProcedure>,\n        NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n      >\n    | undefined;\n};\n\ntype DecorateMutationProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyMutationProcedure,\n> = {\n  setMutationDefaults<TMeta = unknown>(\n    options:\n      | InferMutationOptions<TRoot, TProcedure, TMeta>\n      | ((args: {\n          canonicalMutationFn: NonNullable<\n            InferMutationOptions<TRoot, TProcedure>['mutationFn']\n          >;\n        }) => InferMutationOptions<TRoot, TProcedure, TMeta>),\n  ): void;\n\n  getMutationDefaults(): InferMutationOptions<TRoot, TProcedure> | undefined;\n\n  isMutating(): number;\n};\n\n/**\n * this is the type that is used to add in procedures that can be used on\n * an entire router\n */\ntype DecorateRouter = {\n  /**\n   * Invalidate the full router\n   * @see https://trpc.io/docs/v10/useContext#query-invalidation\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidate(\n    input?: undefined,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions,\n  ): Promise<void>;\n};\n\n/**\n * @internal\n */\nexport type DecoratedProcedureUtilsRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = DecorateRouter & {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? DecorateQueryProcedure<TRoot, $Value>\n      : $Value extends AnyMutationProcedure\n        ? DecorateMutationProcedure<TRoot, $Value>\n        : $Value extends RouterRecord\n          ? DecoratedProcedureUtilsRecord<TRoot, $Value> & DecorateRouter\n          : never\n    : never;\n}; // Add functions that should be available at utils root\n\ntype AnyDecoratedProcedure = DecorateQueryProcedure<any, any> &\n  DecorateMutationProcedure<any, any>;\n\nexport type CreateReactUtils<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  DecoratedTRPCContextProps<TRouter, TSSRContext>,\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\nexport type CreateQueryUtils<TRouter extends AnyRouter> =\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n\nexport const getQueryType = (\n  utilName: keyof AnyDecoratedProcedure,\n): QueryType => {\n  switch (utilName) {\n    case 'queryOptions':\n    case 'fetch':\n    case 'ensureData':\n    case 'prefetch':\n    case 'getData':\n    case 'setData':\n    case 'setQueriesData':\n      return 'query';\n\n    case 'infiniteQueryOptions':\n    case 'fetchInfinite':\n    case 'prefetchInfinite':\n    case 'getInfiniteData':\n    case 'setInfiniteData':\n      return 'infinite';\n\n    case 'setMutationDefaults':\n    case 'getMutationDefaults':\n    case 'isMutating':\n    case 'cancel':\n    case 'invalidate':\n    case 'refetch':\n    case 'reset':\n      return 'any';\n  }\n};\n\n/**\n * @internal\n */\nfunction createRecursiveUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n) {\n  return createRecursiveProxy<CreateQueryUtils<TRouter>>((opts) => {\n    const path = [...opts.path];\n    const utilName = path.pop() as keyof AnyDecoratedProcedure;\n    const args = [...opts.args] as Parameters<\n      AnyDecoratedProcedure[typeof utilName]\n    >;\n    const input = args.shift(); // args can now be spread when input removed\n    const queryType = getQueryType(utilName);\n    const queryKey = getQueryKeyInternal(path, input, queryType);\n\n    const contextMap: Record<keyof AnyDecoratedProcedure, () => unknown> = {\n      infiniteQueryOptions: () =>\n        context.infiniteQueryOptions(path, queryKey, args[0]),\n      queryOptions: () => context.queryOptions(path, queryKey, ...args),\n      /**\n       * DecorateQueryProcedure\n       */\n      fetch: () => context.fetchQuery(queryKey, ...args),\n      fetchInfinite: () => context.fetchInfiniteQuery(queryKey, args[0]),\n      prefetch: () => context.prefetchQuery(queryKey, ...args),\n      prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, args[0]),\n      ensureData: () => context.ensureQueryData(queryKey, ...args),\n      invalidate: () => context.invalidateQueries(queryKey, ...args),\n      reset: () => context.resetQueries(queryKey, ...args),\n      refetch: () => context.refetchQueries(queryKey, ...args),\n      cancel: () => context.cancelQuery(queryKey, ...args),\n      setData: () => {\n        context.setQueryData(queryKey, args[0], args[1]);\n      },\n      setQueriesData: () =>\n        context.setQueriesData(queryKey, args[0], args[1], args[2]),\n      setInfiniteData: () => {\n        context.setInfiniteQueryData(queryKey, args[0], args[1]);\n      },\n      getData: () => context.getQueryData(queryKey),\n      getInfiniteData: () => context.getInfiniteQueryData(queryKey),\n      /**\n       * DecorateMutationProcedure\n       */\n      setMutationDefaults: () =>\n        context.setMutationDefaults(getMutationKeyInternal(path), input),\n      getMutationDefaults: () =>\n        context.getMutationDefaults(getMutationKeyInternal(path)),\n      isMutating: () =>\n        context.isMutating({ mutationKey: getMutationKeyInternal(path) }),\n    };\n\n    return contextMap[utilName]();\n  });\n}\n\n/**\n * @internal\n */\nexport function createReactQueryUtils<TRouter extends AnyRouter, TSSRContext>(\n  context: TRPCContextState<AnyRouter, TSSRContext>,\n) {\n  type CreateReactUtilsReturnType = CreateReactUtils<TRouter, TSSRContext>;\n\n  const clientProxy = createTRPCClientProxy(context.client);\n\n  const proxy = createRecursiveUtilsProxy(\n    context,\n  ) as CreateReactUtilsReturnType;\n\n  return createFlatProxy<CreateReactUtilsReturnType>((key) => {\n    const contextName = key as (typeof contextProps)[number];\n    if (contextName === 'client') {\n      return clientProxy;\n    }\n    if (contextProps.includes(contextName)) {\n      return context[contextName];\n    }\n\n    return proxy[key];\n  });\n}\n\n/**\n * @internal\n */\nexport function createQueryUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n): CreateQueryUtils<TRouter> {\n  return createRecursiveUtilsProxy(context);\n}\n","import type { QueryOptions } from '@tanstack/react-query';\nimport type { TRPCClient } from '@trpc/client';\nimport {\n  getUntypedClient,\n  TRPCUntypedClient,\n  type TRPCClientError,\n} from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { getQueryKeyInternal } from '../../internals/getQueryKey';\nimport type {\n  TrpcQueryOptionsForUseQueries,\n  TrpcQueryOptionsForUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport type { TRPCUseQueryBaseOptions } from '../hooks/types';\n\ntype GetQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\ntype GetSuspenseQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseSuspenseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseSuspenseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseSuspenseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetSuspenseQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseSuspenseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */\nexport function createUseQueries<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>,\n) {\n  const untypedClient: TRPCUntypedClient<TRouter> =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return createRecursiveProxy<\n    UseQueriesProcedureRecord<\n      TRouter['_def']['_config']['$types'],\n      TRouter['_def']['record']\n    >\n  >((opts) => {\n    const arrayPath = opts.path;\n    const dotPath = arrayPath.join('.');\n    const [input, _opts] = opts.args as [\n      unknown,\n      Partial<QueryOptions> & TRPCUseQueryBaseOptions,\n    ];\n\n    const options: QueryOptions = {\n      queryKey: getQueryKeyInternal(arrayPath, input, 'query'),\n      queryFn: () => {\n        return untypedClient.query(dotPath, input, _opts?.trpc);\n      },\n      ..._opts,\n    };\n\n    return options;\n  });\n}\n","import type { TRPCQueryKey } from './getQueryKey';\n\n/**\n * @internal\n */\nexport function getClientArgs<TOptions>(\n  queryKey: TRPCQueryKey,\n  opts: TOptions,\n  infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  },\n) {\n  const path = queryKey[0];\n  let input = queryKey[1]?.input;\n  if (infiniteParams) {\n    input = {\n      ...(input ?? {}),\n      ...(infiniteParams.pageParam ? { cursor: infiniteParams.pageParam } : {}),\n      direction: infiniteParams.direction,\n    };\n  }\n  return [path.join('.'), input, (opts as any)?.trpc] as const;\n}\n","function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import type { QueryClient } from '@tanstack/react-query';\nimport * as React from 'react';\nimport type { TRPCQueryOptionsResult } from '../shared';\nimport type { TRPCHookResult } from '../shared/hooks/types';\nimport type { TRPCQueryKey } from './getQueryKey';\n\nexport function createTRPCOptionsResult(value: {\n  path: readonly string[];\n}): TRPCQueryOptionsResult['trpc'] {\n  const path = value.path.join('.');\n\n  return {\n    path,\n  };\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */\nexport function useHookResult(value: {\n  path: readonly string[];\n}): TRPCHookResult['trpc'] {\n  const result = createTRPCOptionsResult(value);\n  return React.useMemo(() => result, [result]);\n}\n\n/**\n * @internal\n */\nexport async function buildQueryFromAsyncIterable(\n  asyncIterable: AsyncIterable<unknown>,\n  queryClient: QueryClient,\n  queryKey: TRPCQueryKey,\n) {\n  const queryCache = queryClient.getQueryCache();\n\n  const query = queryCache.build(queryClient, {\n    queryKey,\n  });\n\n  query.setState({\n    data: [],\n    status: 'success',\n  });\n\n  const aggregate: unknown[] = [];\n  for await (const value of asyncIterable) {\n    aggregate.push(value);\n\n    query.setState({\n      data: [...aggregate],\n    });\n  }\n  return aggregate;\n}\n","import type { QueryFunctionContext } from '@tanstack/react-query';\nimport {\n  infiniteQueryOptions,\n  queryOptions,\n  skipToken,\n  type QueryClient,\n} from '@tanstack/react-query';\nimport type { TRPCClient, TRPCClientError } from '@trpc/client';\nimport { getUntypedClient, TRPCUntypedClient } from '@trpc/client';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport type { AnyClientTypes } from '@trpc/server/unstable-core-do-not-import/clientish/inferrable';\nimport { getClientArgs } from '../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  createTRPCOptionsResult,\n} from '../internals/trpcResult';\nimport type { DefinedTRPCQueryOptionsOut } from '../shared';\nimport { type TRPCQueryUtils } from '../shared';\n\nexport interface CreateQueryUtilsOptions<TRouter extends AnyRouter> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter> | TRPCUntypedClient<TRouter>;\n  /**\n   * The `QueryClient` from `react-query`\n   */\n  queryClient: QueryClient;\n}\n\n/**\n * Creates a set of utility functions that can be used to interact with `react-query`\n * @param opts the `TRPCClient` and `QueryClient` to use\n * @returns a set of utility functions that can be used to interact with `react-query`\n * @internal\n */\nexport function createUtilityFunctions<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n): TRPCQueryUtils<TRouter> {\n  const { client, queryClient } = opts;\n  const untypedClient =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return {\n    infiniteQueryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam,\n          }),\n        );\n\n        return result;\n      };\n\n      return Object.assign(\n        infiniteQueryOptions({\n          ...opts,\n          initialData: opts?.initialData as any,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n          initialPageParam: (opts?.initialCursor as any) ?? null,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      );\n    },\n\n    queryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts),\n        );\n\n        if (isAsyncIterable(result)) {\n          return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n\n        return result;\n      };\n\n      return Object.assign(\n        queryOptions({\n          ...opts,\n          initialData: opts?.initialData,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      ) as DefinedTRPCQueryOptionsOut<\n        unknown,\n        unknown,\n        TRPCClientError<AnyClientTypes>\n      >;\n    },\n\n    fetchQuery: (queryKey, opts) => {\n      return queryClient.fetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    fetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.fetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    prefetchQuery: (queryKey, opts) => {\n      return queryClient.prefetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    prefetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.prefetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    ensureQueryData: (queryKey, opts) => {\n      return queryClient.ensureQueryData({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    invalidateQueries: (queryKey, filters, options) => {\n      return queryClient.invalidateQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n    resetQueries: (queryKey, filters, options) => {\n      return queryClient.resetQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    refetchQueries: (queryKey, filters, options) => {\n      return queryClient.refetchQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    cancelQuery: (queryKey, options) => {\n      return queryClient.cancelQueries(\n        {\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    setQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    // eslint-disable-next-line max-params\n    setQueriesData: (queryKey, filters, updater, options) => {\n      return queryClient.setQueriesData(\n        {\n          ...filters,\n          queryKey,\n        },\n        updater,\n        options,\n      );\n    },\n\n    getQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setInfiniteQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    getInfiniteQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setMutationDefaults: (mutationKey, options) => {\n      const path = mutationKey[0];\n      const canonicalMutationFn = (input: unknown) => {\n        return untypedClient.mutation(\n          ...getClientArgs([path, { input }], opts),\n        );\n      };\n      return queryClient.setMutationDefaults(\n        mutationKey,\n        typeof options === 'function'\n          ? options({ canonicalMutationFn })\n          : options,\n      );\n    },\n\n    getMutationDefaults: (mutationKey) => {\n      return queryClient.getMutationDefaults(mutationKey);\n    },\n\n    isMutating: (filters) => {\n      return queryClient.isMutating({\n        ...filters,\n        exact: true,\n      });\n    },\n  };\n}\n","// TODO: Look into fixing react-compiler support\n/* eslint-disable react-hooks/react-compiler */\nimport {\n  useInfiniteQuery as __useInfiniteQuery,\n  useMutation as __useMutation,\n  usePrefetchInfiniteQuery as __usePrefetchInfiniteQuery,\n  useQueries as __useQueries,\n  useQuery as __useQuery,\n  useSuspenseInfiniteQuery as __useSuspenseInfiniteQuery,\n  useSuspenseQueries as __useSuspenseQueries,\n  useSuspenseQuery as __useSuspenseQuery,\n  usePrefetchQuery as _usePrefetchQuery,\n  hashKey,\n  skipToken,\n} from '@tanstack/react-query';\nimport type { TRPCClientErrorLike } from '@trpc/client';\nimport {\n  createTRPCClient,\n  getUntypedClient,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type { SSRState, TRPCContextState } from '../../internals/context';\nimport { TRPCContext } from '../../internals/context';\nimport { getClientArgs } from '../../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  useHookResult,\n} from '../../internals/trpcResult';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport { createUtilityFunctions } from '../../utils/createUtilityFunctions';\nimport { createUseQueries } from '../proxy/useQueriesProxy';\nimport type { CreateTRPCReactOptions, UseMutationOverride } from '../types';\nimport type {\n  TRPCProvider,\n  TRPCQueryOptions,\n  TRPCSubscriptionConnectingResult,\n  TRPCSubscriptionIdleResult,\n  TRPCSubscriptionResult,\n  UseTRPCInfiniteQueryOptions,\n  UseTRPCInfiniteQueryResult,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCPrefetchInfiniteQueryOptions,\n  UseTRPCPrefetchQueryOptions,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseInfiniteQueryOptions,\n  UseTRPCSuspenseInfiniteQueryResult,\n  UseTRPCSuspenseQueryOptions,\n  UseTRPCSuspenseQueryResult,\n} from './types';\n\nconst trackResult = <T extends object>(\n  result: T,\n  onTrackResult: (key: keyof T) => void,\n): T => {\n  const trackedResult = new Proxy(result, {\n    get(target, prop) {\n      onTrackResult(prop as keyof T);\n      return target[prop as keyof T];\n    },\n  });\n\n  return trackedResult;\n};\n\n/**\n * @internal\n */\nexport function createRootHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(config?: CreateTRPCReactOptions<TRouter>) {\n  const mutationSuccessOverride: UseMutationOverride['onSuccess'] =\n    config?.overrides?.useMutation?.onSuccess ??\n    ((options) => options.originalFn());\n\n  type TError = TRPCClientErrorLike<TRouter>;\n\n  type ProviderContext = TRPCContextState<TRouter, TSSRContext>;\n\n  const Context = (config?.context ??\n    TRPCContext) as React.Context<ProviderContext>;\n\n  const createClient = createTRPCClient<TRouter>;\n\n  const TRPCProvider: TRPCProvider<TRouter, TSSRContext> = (props) => {\n    const { abortOnUnmount = false, queryClient, ssrContext } = props;\n    const [ssrState, setSSRState] = React.useState<SSRState>(\n      props.ssrState ?? false,\n    );\n\n    const client: TRPCUntypedClient<TRouter> =\n      props.client instanceof TRPCUntypedClient\n        ? props.client\n        : getUntypedClient(props.client);\n\n    const fns = React.useMemo(\n      () =>\n        createUtilityFunctions({\n          client,\n          queryClient,\n        }),\n      [client, queryClient],\n    );\n\n    const contextValue = React.useMemo<ProviderContext>(\n      () => ({\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext ?? null,\n        ssrState,\n        ...fns,\n      }),\n      [abortOnUnmount, client, fns, queryClient, ssrContext, ssrState],\n    );\n\n    React.useEffect(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState((state) => (state ? 'mounted' : false));\n    }, []);\n    return (\n      <Context.Provider value={contextValue}>{props.children}</Context.Provider>\n    );\n  };\n\n  function useContext() {\n    const context = React.useContext(Context);\n\n    if (!context) {\n      throw new Error(\n        'Unable to find tRPC Context. Did you forget to wrap your App inside `withTRPC` HoC?',\n      );\n    }\n    return context;\n  }\n\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @see https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded<\n    TOptions extends { retryOnMount?: boolean } | undefined,\n  >(queryKey: TRPCQueryKey, opts: TOptions): TOptions {\n    const { queryClient, ssrState } = useContext();\n    return ssrState &&\n      ssrState !== 'mounted' &&\n      queryClient.getQueryCache().find({ queryKey })?.state.status === 'error'\n      ? {\n          retryOnMount: false,\n          ...opts,\n        }\n      : opts;\n  }\n\n  function useQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCQueryResult<unknown, TError> {\n    const context = useContext();\n    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } =\n      context;\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchQuery(queryKey, opts as any);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useQuery(\n      {\n        ...ssrOpts,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : async (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              const result = await client.query(\n                ...getClientArgs(queryKey, actualOpts),\n              );\n\n              if (isAsyncIterable(result)) {\n                return buildQueryFromAsyncIterable(\n                  result,\n                  queryClient,\n                  queryKey,\n                );\n              }\n              return result;\n            },\n      },\n      queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n\n  function usePrefetchQuery(\n    path: string[],\n    input: unknown,\n    opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const isInputSkipToken = input === skipToken;\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    _usePrefetchQuery({\n      ...opts,\n      queryKey: queryKey as any,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              trpc: {\n                ...opts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(...getClientArgs(queryKey, actualOpts));\n          },\n    });\n  }\n\n  function useSuspenseQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseQueryResult<unknown, TError> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    const hook = __useSuspenseQuery(\n      {\n        ...opts,\n        queryKey: queryKey as any,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...opts,\n            trpc: {\n              ...opts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : { signal: null }),\n            },\n          };\n\n          return context.client.query(...getClientArgs(queryKey, actualOpts));\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return [hook.data, hook as any];\n  }\n\n  function useMutation(\n    path: readonly string[],\n    opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>,\n  ): UseTRPCMutationResult<unknown, TError, unknown, unknown> {\n    const { client, queryClient } = useContext();\n\n    const mutationKey = getMutationKeyInternal(path);\n\n    const defaultOpts = queryClient.defaultMutationOptions(\n      queryClient.getMutationDefaults(mutationKey),\n    );\n\n    const hook = __useMutation(\n      {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn: (input) => {\n          return client.mutation(...getClientArgs([path, { input }], opts));\n        },\n        onSuccess(...args) {\n          const originalFn = () =>\n            opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n\n          return mutationSuccessOverride({\n            originalFn,\n            queryClient,\n            meta: opts?.meta ?? defaultOpts?.meta ?? {},\n          });\n        },\n      },\n      queryClient,\n    ) as UseTRPCMutationResult<unknown, TError, unknown, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n  const initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'> = {\n    data: undefined,\n    error: null,\n    status: 'idle',\n  };\n\n  const initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  > = {\n    data: undefined,\n    error: null,\n    status: 'connecting',\n  };\n\n  /* istanbul ignore next -- @preserve */\n  function useSubscription(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSubscriptionOptions<unknown, TError>,\n  ) {\n    const enabled = opts?.enabled ?? input !== skipToken;\n    const queryKey = hashKey(getQueryKeyInternal(path, input, 'any'));\n    const { client } = useContext();\n\n    const optsRef = React.useRef<typeof opts>(opts);\n    React.useEffect(() => {\n      optsRef.current = opts;\n    });\n\n    type $Result = TRPCSubscriptionResult<unknown, TError>;\n\n    const [trackedProps] = React.useState(new Set<keyof $Result>([]));\n\n    const addTrackedProp = React.useCallback(\n      (key: keyof $Result) => {\n        trackedProps.add(key);\n      },\n      [trackedProps],\n    );\n\n    const currentSubscriptionRef = React.useRef<Unsubscribable>(null);\n\n    const updateState = React.useCallback(\n      (callback: (prevState: $Result) => $Result) => {\n        const prev = resultRef.current;\n        const next = (resultRef.current = callback(prev));\n\n        let shouldUpdate = false;\n        for (const key of trackedProps) {\n          if (prev[key] !== next[key]) {\n            shouldUpdate = true;\n            break;\n          }\n        }\n        if (shouldUpdate) {\n          setState(trackResult(next, addTrackedProp));\n        }\n      },\n      [addTrackedProp, trackedProps],\n    );\n\n    const reset = React.useCallback((): void => {\n      // unsubscribe from the previous subscription\n      currentSubscriptionRef.current?.unsubscribe();\n\n      if (!enabled) {\n        updateState(() => ({ ...initialStateIdle, reset }));\n        return;\n      }\n      updateState(() => ({ ...initialStateConnecting, reset }));\n      const subscription = client.subscription(\n        path.join('.'),\n        input ?? undefined,\n        {\n          onStarted: () => {\n            optsRef.current.onStarted?.();\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              error: null,\n            }));\n          },\n          onData: (data) => {\n            optsRef.current.onData?.(data);\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              data,\n              error: null,\n            }));\n          },\n          onError: (error) => {\n            optsRef.current.onError?.(error);\n            updateState((prev) => ({\n              ...prev,\n              status: 'error',\n              error,\n            }));\n          },\n          onConnectionStateChange: (result) => {\n            updateState((prev) => {\n              switch (result.state) {\n                case 'idle':\n                  return {\n                    ...prev,\n                    status: result.state,\n                    error: null,\n                    data: undefined,\n                  };\n                case 'connecting':\n                  return {\n                    ...prev,\n                    error: result.error,\n                    status: result.state,\n                  };\n\n                case 'pending':\n                  // handled when data is / onStarted\n                  return prev;\n              }\n            });\n          },\n          onComplete: () => {\n            optsRef.current.onComplete?.();\n\n            // In the case of WebSockets, the connection might not be idle so `onConnectionStateChange` will not be called until the connection is closed.\n            // In this case, we need to set the state to idle manually.\n            updateState((prev) => ({\n              ...prev,\n              status: 'idle',\n              error: null,\n              data: undefined,\n            }));\n\n            // (We might want to add a `connectionState` to the state to track the connection state separately)\n          },\n        },\n      );\n\n      currentSubscriptionRef.current = subscription;\n\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [client, queryKey, enabled, updateState]);\n    React.useEffect(() => {\n      reset();\n\n      return () => {\n        currentSubscriptionRef.current?.unsubscribe();\n      };\n    }, [reset]);\n\n    const resultRef = React.useRef<$Result>(\n      enabled\n        ? { ...initialStateConnecting, reset }\n        : { ...initialStateIdle, reset },\n    );\n\n    const [state, setState] = React.useState<$Result>(\n      trackResult(resultRef.current, addTrackedProp),\n    );\n\n    return state;\n  }\n\n  function useInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCInfiniteQueryResult<unknown, TError, unknown> {\n    const {\n      client,\n      ssrState,\n      prefetchInfiniteQuery,\n      queryClient,\n      abortOnUnmount,\n    } = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchInfiniteQuery(queryKey, { ...defaultOpts, ...opts } as any);\n    }\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useInfiniteQuery(\n      {\n        ...ssrOpts,\n        initialPageParam: opts.initialCursor ?? null,\n        persister: opts.persister,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              return client.query(\n                ...getClientArgs(queryKey, actualOpts, {\n                  pageParam:\n                    queryFunctionContext.pageParam ?? opts.initialCursor,\n                  direction: queryFunctionContext.direction,\n                }),\n              );\n            },\n      },\n      queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n    return hook;\n  }\n\n  function usePrefetchInfiniteQuery(\n    path: string[],\n    input: unknown,\n    opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    __usePrefetchInfiniteQuery({\n      ...opts,\n      initialPageParam: opts.initialCursor ?? null,\n      queryKey,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              ...ssrOpts,\n              trpc: {\n                ...ssrOpts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(\n              ...getClientArgs(queryKey, actualOpts, {\n                pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n                direction: queryFunctionContext.direction,\n              }),\n            );\n          },\n    });\n  }\n\n  function useSuspenseInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseInfiniteQueryResult<unknown, TError, unknown> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    const hook = __useSuspenseInfiniteQuery(\n      {\n        ...opts,\n        initialPageParam: opts.initialCursor ?? null,\n        queryKey,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...ssrOpts,\n            trpc: {\n              ...ssrOpts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : {}),\n            },\n          };\n\n          return context.client.query(\n            ...getClientArgs(queryKey, actualOpts, {\n              pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n              direction: queryFunctionContext.direction,\n            }),\n          );\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [hook.data!, hook as any];\n  }\n\n  const useQueries: TRPCUseQueries<TRouter> = (queriesCallback, options) => {\n    const { ssrState, queryClient, prefetchQuery, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    if (typeof window === 'undefined' && ssrState === 'prepass') {\n      for (const query of queries) {\n        const queryOption = query as TRPCQueryOptions<any, any>;\n        if (\n          queryOption.trpc?.ssr !== false &&\n          !queryClient.getQueryCache().find({ queryKey: queryOption.queryKey })\n        ) {\n          void prefetchQuery(queryOption.queryKey, queryOption as any);\n        }\n      }\n    }\n\n    return __useQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n        combine: options?.combine as any,\n      },\n      queryClient,\n    );\n  };\n\n  const useSuspenseQueries: TRPCUseSuspenseQueries<TRouter> = (\n    queriesCallback,\n  ) => {\n    const { queryClient, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    const hook = __useSuspenseQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryFn: query.queryFn,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n      },\n      queryClient,\n    );\n\n    return [hook.map((h) => h.data), hook] as any;\n  };\n\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useUtils: useContext,\n    useQuery,\n    usePrefetchQuery,\n    useSuspenseQuery,\n    useQueries,\n    useSuspenseQueries,\n    useMutation,\n    useSubscription,\n    useInfiniteQuery,\n    usePrefetchInfiniteQuery,\n    useSuspenseInfiniteQuery,\n  };\n}\n\n/**\n * Infer the type of a `createReactQueryHooks` function\n * @internal\n */\nexport type CreateReactQueryHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n> = ReturnType<typeof createRootHooks<TRouter, TSSRContext>>;\n","import type { QueryClientConfig } from '@tanstack/react-query';\nimport { QueryClient } from '@tanstack/react-query';\n\n/**\n * @internal\n */\nexport type CreateTRPCReactQueryClientConfig =\n  | {\n      queryClient?: QueryClient;\n      queryClientConfig?: never;\n    }\n  | {\n      queryClientConfig?: QueryClientConfig;\n      queryClient?: never;\n    };\n\n/**\n * @internal\n */\nexport const getQueryClient = (config: CreateTRPCReactQueryClientConfig) =>\n  config.queryClient ?? new QueryClient(config.queryClientConfig);\n"],"x_google_ignoreList":[5],"mappings":"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"}